;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2010 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B231-7414-99			    |
; |		       NCFTA Canada/Concordia University		    |
; +-------------------------------------------------------------------------+
;
;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2010 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B231-7414-99			    |
; |		       NCFTA Canada/Concordia University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	A2972D1C50AF0CD1A3BCC748B41B7773
; Input	CRC32 :	02948216

; ---------------------------------------------------------------------------
; File Name   :	c:\Users\farhadi\Desktop\dll4\BugHandler.dll
; Format      :	Portable executable for	80386 (PE)
; Imagebase   :	60000000
; Section 1. (virtual address 00001000)
; Virtual size			: 00005DCF (  24015.)
; Section size in file		: 00005E00 (  24064.)
; Offset to raw	data for section: 00000400
; Flags	60000020: Text Executable Readable
; Alignment	: default
; OS type	  :  MS	Windows
; Application type:  DLL 32bit

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60001000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	4
		mov	eax, [ebp+0Ch]
		push	eax
		call	ds:IsBadWritePtr
		cmp	eax, 1
		jnz	short loc_60001026
		push	57h
		call	ds:SetLastError
		xor	eax, eax
		jmp	loc_600010D7
; ---------------------------------------------------------------------------

loc_60001026:				; CODE XREF: .text:60001015j
		cmp	dword ptr [ebp+8], 0
		jnz	short loc_6000103B
		push	57h
		call	ds:SetLastError
		xor	eax, eax
		jmp	loc_600010D7
; ---------------------------------------------------------------------------

loc_6000103B:				; CODE XREF: .text:6000102Aj
		lea	ecx, [ebp-4]
		push	ecx
		push	0
		push	0
		call	ds:GetCurrentProcessId
		push	eax
		call	_GetLoadedModules@16 ; GetLoadedModules(x,x,x,x)
		mov	[ebp-8], eax
		cmp	dword ptr [ebp-8], 0
		jz	short loc_6000105E
		cmp	dword ptr [ebp-4], 0
		jnz	short loc_60001062

loc_6000105E:				; CODE XREF: .text:60001056j
		xor	eax, eax
		jmp	short loc_600010D7
; ---------------------------------------------------------------------------

loc_60001062:				; CODE XREF: .text:6000105Cj
		mov	edx, [ebp-4]
		shl	edx, 2
		push	edx
		push	8
		mov	eax, [ebp+8]
		push	eax
		call	ds:HeapAlloc
		mov	[ebp-10h], eax
		cmp	dword ptr [ebp-10h], 0
		jnz	short loc_60001082
		xor	eax, eax
		jmp	short loc_600010D7
; ---------------------------------------------------------------------------

loc_60001082:				; CODE XREF: .text:6000107Cj
		mov	ecx, [ebp+0Ch]
		push	ecx
		mov	edx, [ebp-10h]
		push	edx
		mov	eax, [ebp-4]
		push	eax
		call	ds:GetCurrentProcessId
		push	eax
		call	_GetLoadedModules@16 ; GetLoadedModules(x,x,x,x)
		mov	[ebp-8], eax
		call	ds:GetLastError
		mov	[ebp-0Ch], eax
		cmp	dword ptr [ebp-8], 0
		jnz	short loc_600010CC
		mov	ecx, [ebp-10h]
		push	ecx
		call	ds:free
		add	esp, 4
		mov	dword ptr [ebp-10h], 0
		mov	edx, [ebp-0Ch]
		push	edx
		call	ds:SetLastError
		jmp	short loc_600010D4
; ---------------------------------------------------------------------------

loc_600010CC:				; CODE XREF: .text:600010AAj
		push	0
		call	ds:SetLastError

loc_600010D4:				; CODE XREF: .text:600010CAj
		mov	eax, [ebp-10h]

loc_600010D7:				; CODE XREF: .text:60001021j
					; .text:60001036j ...
		mov	esp, ebp
		pop	ebp
		retn	8
; ---------------------------------------------------------------------------
		align 10h
; Exported entry   3. _BSUGetModuleBaseName@16

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	BSUGetModuleBaseName(int, HMODULE hModule, LPVOID lpString1, UINT_PTR ucb)
		public _BSUGetModuleBaseName@16
_BSUGetModuleBaseName@16 proc near	; CODE XREF: GetFaultReason(x)+64p
					; GetFaultReason(x)+17Bp ...

arg_0		= dword	ptr  8
hModule		= dword	ptr  0Ch
lpString1	= dword	ptr  10h
ucb		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		call	_IsNT@0		; IsNT()
		cmp	eax, 1
		jnz	short loc_60001104
		mov	eax, [ebp+ucb]
		push	eax
		mov	ecx, [ebp+lpString1]
		push	ecx
		mov	edx, [ebp+hModule]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	sub_60005DD0
		jmp	short loc_60001119
; ---------------------------------------------------------------------------

loc_60001104:				; CODE XREF: BSUGetModuleBaseName(x,x,x,x)+Bj
		mov	ecx, [ebp+ucb]
		push	ecx		; ucb
		mov	edx, [ebp+lpString1]
		push	edx		; lpString1
		mov	eax, [ebp+hModule]
		push	eax		; hModule
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	sub_60001120

loc_60001119:				; CODE XREF: BSUGetModuleBaseName(x,x,x,x)+22j
		pop	ebp
		retn	10h
_BSUGetModuleBaseName@16 endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	sub_60001120(int, HMODULE hModule, LPVOID lpString1, UINT_PTR ucb)
sub_60001120	proc near		; CODE XREF: BSUGetModuleBaseName(x,x,x,x)+34p

var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
lpString2	= dword	ptr -118h
iMaxLength	= dword	ptr -114h
String		= byte ptr -110h
var_4		= dword	ptr -4
hModule		= dword	ptr  0Ch
lpString1	= dword	ptr  10h
ucb		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		mov	eax, [ebp+ucb]
		push	eax		; ucb
		mov	ecx, [ebp+lpString1]
		push	ecx		; lp
		call	ds:IsBadWritePtr
		cmp	eax, 1
		jnz	short loc_6000114B
		push	57h		; dwErrCode
		call	ds:SetLastError
		xor	eax, eax
		jmp	loc_6000126B
; ---------------------------------------------------------------------------

loc_6000114B:				; CODE XREF: sub_60001120+1Aj
		push	104h		; nSize
		lea	edx, [ebp+String]
		push	edx		; lpFilename
		mov	eax, [ebp+hModule]
		push	eax		; hModule
		call	ds:GetModuleFileNameA
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_60001171
		xor	eax, eax
		jmp	loc_6000126B
; ---------------------------------------------------------------------------

loc_60001171:				; CODE XREF: sub_60001120+48j
		push	5Ch		; int
		lea	ecx, [ebp+String]
		push	ecx		; Str
		call	sub_60001500
		add	esp, 8
		mov	[ebp+lpString2], eax
		cmp	[ebp+lpString2], 0
		jz	short loc_600011FC
		mov	edx, [ebp+lpString2]
		add	edx, 1
		mov	[ebp+lpString2], edx
		mov	eax, [ebp+lpString2]
		push	eax		; lpString
		call	ds:lstrlenA
		add	eax, 1
		cmp	[ebp+ucb], eax
		jge	short loc_600011C0
		mov	ecx, [ebp+ucb]
		mov	[ebp+var_11C], ecx
		jmp	short loc_600011D6
; ---------------------------------------------------------------------------

loc_600011C0:				; CODE XREF: sub_60001120+93j
		mov	edx, [ebp+lpString2]
		push	edx		; lpString
		call	ds:lstrlenA
		add	eax, 1
		mov	[ebp+var_11C], eax

loc_600011D6:				; CODE XREF: sub_60001120+9Ej
		mov	eax, [ebp+var_11C]
		mov	[ebp+iMaxLength], eax
		mov	ecx, [ebp+iMaxLength]
		push	ecx		; iMaxLength
		mov	edx, [ebp+lpString2]
		push	edx		; lpString2
		mov	eax, [ebp+lpString1]
		push	eax		; lpString1
		call	ds:lstrcpynA
		jmp	short loc_60001256
; ---------------------------------------------------------------------------

loc_600011FC:				; CODE XREF: sub_60001120+6Fj
		lea	ecx, [ebp+String]
		push	ecx		; lpString
		call	ds:lstrlenA
		add	eax, 1
		cmp	[ebp+ucb], eax
		jge	short loc_6000121C
		mov	edx, [ebp+ucb]
		mov	[ebp+var_120], edx
		jmp	short loc_60001232
; ---------------------------------------------------------------------------

loc_6000121C:				; CODE XREF: sub_60001120+EFj
		lea	eax, [ebp+String]
		push	eax		; lpString
		call	ds:lstrlenA
		add	eax, 1
		mov	[ebp+var_120], eax

loc_60001232:				; CODE XREF: sub_60001120+FAj
		mov	ecx, [ebp+var_120]
		mov	[ebp+iMaxLength], ecx
		mov	edx, [ebp+iMaxLength]
		push	edx		; iMaxLength
		lea	eax, [ebp+String]
		push	eax		; lpString2
		mov	ecx, [ebp+lpString1]
		push	ecx		; lpString1
		call	ds:lstrcpynA

loc_60001256:				; CODE XREF: sub_60001120+DAj
		mov	edx, [ebp+lpString1]
		add	edx, [ebp+iMaxLength]
		mov	byte ptr [edx],	0
		mov	eax, [ebp+iMaxLength]
		sub	eax, 1

loc_6000126B:				; CODE XREF: sub_60001120+26j
					; sub_60001120+4Cj
		mov	esp, ebp
		pop	ebp
		retn	10h
sub_60001120	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   5. _BSUSymInitialize@16

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	BSUSymInitialize(DWORD dwProcessId, HANDLE hProcess, PCSTR UserSearchPath, BOOL	fInvadeProcess)
		public _BSUSymInitialize@16
_BSUSymInitialize@16 proc near		; CODE XREF: sub_600029E0+3Dp
					; DATA XREF: .rdata:off_60008C28o

var_138		= dword	ptr -138h
var_134		= dword	ptr -134h
var_130		= dword	ptr -130h
var_12C		= dword	ptr -12Ch
var_128		= dword	ptr -128h
var_124		= dword	ptr -124h
hFile		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
FileName	= byte ptr -110h
var_4		= dword	ptr -4
dwProcessId	= dword	ptr  8
hProcess	= dword	ptr  0Ch
UserSearchPath	= dword	ptr  10h
fInvadeProcess	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		call	_IsNT@0		; IsNT()
		cmp	eax, 1
		jz	short loc_60001299
		cmp	[ebp+fInvadeProcess], 0
		jnz	short loc_600012B5

loc_60001299:				; CODE XREF: BSUSymInitialize(x,x,x,x)+11j
		mov	eax, [ebp+fInvadeProcess]
		push	eax		; fInvadeProcess
		mov	ecx, [ebp+UserSearchPath]
		push	ecx		; UserSearchPath
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymInitialize
		jmp	loc_600014AA
; ---------------------------------------------------------------------------
		jmp	loc_600014A5
; ---------------------------------------------------------------------------

loc_600012B5:				; CODE XREF: BSUSymInitialize(x,x,x,x)+17j
		mov	eax, [ebp+fInvadeProcess]
		push	eax		; fInvadeProcess
		mov	ecx, [ebp+UserSearchPath]
		push	ecx		; UserSearchPath
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymInitialize
		mov	[ebp+var_114], eax
		cmp	[ebp+var_114], 0
		jnz	short loc_600012DD
		xor	eax, eax
		jmp	loc_600014AA
; ---------------------------------------------------------------------------

loc_600012DD:				; CODE XREF: BSUSymInitialize(x,x,x,x)+54j
		lea	eax, [ebp+var_4]
		push	eax		; lp
		push	0		; int
		push	0		; int
		mov	ecx, [ebp+dwProcessId]
		push	ecx		; dwProcessId
		call	_GetLoadedModules@16 ; GetLoadedModules(x,x,x,x)
		test	eax, eax
		jnz	short loc_60001303
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymCleanup
		xor	eax, eax
		jmp	loc_600014AA
; ---------------------------------------------------------------------------

loc_60001303:				; CODE XREF: BSUSymInitialize(x,x,x,x)+70j
		xor	ecx, ecx
		mov	eax, [ebp+var_4]
		mov	edx, 4
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		push	ecx
		call	unknown_libname_6 ; Microsoft VisualC 2-10/net runtime
		add	esp, 4
		mov	[ebp+var_128], eax
		mov	eax, [ebp+var_128]
		mov	[ebp+var_118], eax
		lea	ecx, [ebp+var_4]
		push	ecx		; lp
		mov	edx, [ebp+var_118]
		push	edx		; int
		mov	eax, [ebp+var_4]
		push	eax		; int
		mov	ecx, [ebp+dwProcessId]
		push	ecx		; dwProcessId
		call	_GetLoadedModules@16 ; GetLoadedModules(x,x,x,x)
		test	eax, eax
		jnz	short loc_60001379
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymCleanup
		mov	eax, [ebp+var_118]
		mov	[ebp+var_12C], eax
		mov	ecx, [ebp+var_12C]
		push	ecx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		xor	eax, eax
		jmp	loc_600014AA
; ---------------------------------------------------------------------------

loc_60001379:				; CODE XREF: BSUSymInitialize(x,x,x,x)+CBj
		mov	[ebp+var_11C], 0
		jmp	short loc_60001394
; ---------------------------------------------------------------------------

loc_60001385:				; CODE XREF: BSUSymInitialize(x,x,x,x):loc_60001485j
		mov	edx, [ebp+var_11C]
		add	edx, 1
		mov	[ebp+var_11C], edx

loc_60001394:				; CODE XREF: BSUSymInitialize(x,x,x,x)+103j
		mov	eax, [ebp+var_11C]
		cmp	eax, [ebp+var_4]
		jnb	loc_6000148A
		push	104h		; nSize
		lea	ecx, [ebp+FileName]
		push	ecx		; lpFilename
		mov	edx, [ebp+var_11C]
		mov	eax, [ebp+var_118]
		mov	ecx, [eax+edx*4]
		push	ecx		; hModule
		call	ds:GetModuleFileNameA
		test	eax, eax
		jnz	short loc_600013F5
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymCleanup
		mov	eax, [ebp+var_118]
		mov	[ebp+var_130], eax
		mov	ecx, [ebp+var_130]
		push	ecx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		xor	eax, eax
		jmp	loc_600014AA
; ---------------------------------------------------------------------------

loc_600013F5:				; CODE XREF: BSUSymInitialize(x,x,x,x)+147j
		push	0		; hTemplateFile
		push	0		; dwFlagsAndAttributes
		push	3		; dwCreationDisposition
		push	0		; lpSecurityAttributes
		push	1		; dwShareMode
		push	80000000h	; dwDesiredAccess
		lea	edx, [ebp+FileName]
		push	edx		; lpFileName
		call	ds:CreateFileA
		mov	[ebp+hFile], eax
		push	0		; SizeOfDll
		mov	eax, [ebp+var_11C]
		mov	ecx, [ebp+var_118]
		mov	edx, [ecx+eax*4]
		push	edx		; BaseOfDll
		push	0		; ModuleName
		lea	eax, [ebp+FileName]
		push	eax		; ImageName
		mov	ecx, [ebp+hFile]
		push	ecx		; hFile
		mov	edx, [ebp+hProcess]
		push	edx		; hProcess
		call	ds:SymLoadModule
		test	eax, eax
		jnz	short loc_60001485
		call	ds:GetLastError
		mov	[ebp+var_124], eax
		cmp	[ebp+var_124], 0
		jz	short loc_60001485
		mov	eax, [ebp+hProcess]
		push	eax		; hProcess
		call	ds:SymCleanup
		mov	ecx, [ebp+var_118]
		mov	[ebp+var_134], ecx
		mov	edx, [ebp+var_134]
		push	edx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		xor	eax, eax
		jmp	short loc_600014AA
; ---------------------------------------------------------------------------

loc_60001485:				; CODE XREF: BSUSymInitialize(x,x,x,x)+1C5j
					; BSUSymInitialize(x,x,x,x)+1DAj
		jmp	loc_60001385
; ---------------------------------------------------------------------------

loc_6000148A:				; CODE XREF: BSUSymInitialize(x,x,x,x)+11Dj
		mov	eax, [ebp+var_118]
		mov	[ebp+var_138], eax
		mov	ecx, [ebp+var_138]
		push	ecx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_600014A5:				; CODE XREF: BSUSymInitialize(x,x,x,x)+30j
		mov	eax, 1

loc_600014AA:				; CODE XREF: BSUSymInitialize(x,x,x,x)+2Bj
					; BSUSymInitialize(x,x,x,x)+58j ...
		mov	esp, ebp
		pop	ebp
		retn	10h
_BSUSymInitialize@16 endp

; Exported entry   4. _BSUGetModuleFileNameEx@20

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	BSUGetModuleFileNameEx(int, int, int, char *Dest, int)
		public _BSUGetModuleFileNameEx@20
_BSUGetModuleFileNameEx@20 proc	near	; DATA XREF: .rdata:off_60008C28o

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
Dest		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		call	_IsNT@0		; IsNT()
		cmp	eax, 1
		jnz	short loc_600014D8
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	sub_60005E10
		jmp	short loc_600014F1
; ---------------------------------------------------------------------------

loc_600014D8:				; CODE XREF: BSUGetModuleFileNameEx(x,x,x,x,x)+Bj
		mov	edx, [ebp+arg_10]
		push	edx		; int
		mov	eax, [ebp+Dest]
		push	eax		; Dest
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	sub_600060F0

loc_600014F1:				; CODE XREF: BSUGetModuleFileNameEx(x,x,x,x,x)+26j
		pop	ebp
		retn	14h
_BSUGetModuleFileNameEx@20 endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_60001500(char	*Str, int)
sub_60001500	proc near		; CODE XREF: sub_60001120+5Ap
					; sub_60003420+B4p

Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax		; Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	ds:strrchr
		add	esp, 8
		pop	ebp
		retn
sub_60001500	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  30. _SetCrashHandlerFilter@4

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	SetCrashHandlerFilter(FARPROC lpfn)
		public _SetCrashHandlerFilter@4
_SetCrashHandlerFilter@4 proc near	; DATA XREF: .rdata:off_60008C28o

lpfn		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+lpfn], 0
		jnz	short loc_60001587
		cmp	lpTopLevelExceptionFilter, 0
		jz	short loc_60001585
		mov	eax, lpTopLevelExceptionFilter
		push	eax		; lpTopLevelExceptionFilter
		call	ds:SetUnhandledExceptionFilter
		mov	lpTopLevelExceptionFilter, 0
		cmp	lpMem, 0
		jz	short loc_6000157B
		mov	ecx, lpMem
		push	ecx		; lpMem
		push	0		; dwFlags
		call	ds:GetProcessHeap
		push	eax		; hHeap
		call	ds:HeapFree
		mov	lpMem, 0
		mov	dword_6000A7E4,	0

loc_6000157B:				; CODE XREF: SetCrashHandlerFilter(x)+2Fj
		mov	lpfn, 0

loc_60001585:				; CODE XREF: SetCrashHandlerFilter(x)+10j
		jmp	short loc_600015BB
; ---------------------------------------------------------------------------

loc_60001587:				; CODE XREF: SetCrashHandlerFilter(x)+7j
		mov	edx, [ebp+lpfn]
		push	edx		; lpfn
		call	ds:IsBadCodePtr
		cmp	eax, 1
		jnz	short loc_6000159A
		xor	eax, eax
		jmp	short loc_600015C0
; ---------------------------------------------------------------------------

loc_6000159A:				; CODE XREF: SetCrashHandlerFilter(x)+74j
		mov	eax, [ebp+lpfn]
		mov	lpfn, eax
		cmp	lpTopLevelExceptionFilter, 0
		jnz	short loc_600015BB
		push	offset _CrashHandlerExceptionFilter@4 ;	lpTopLevelExceptionFilter
		call	ds:SetUnhandledExceptionFilter
		mov	lpTopLevelExceptionFilter, eax

loc_600015BB:				; CODE XREF: SetCrashHandlerFilter(x):loc_60001585j
					; SetCrashHandlerFilter(x)+89j
		mov	eax, 1

loc_600015C0:				; CODE XREF: SetCrashHandlerFilter(x)+78j
		pop	ebp
		retn	4
_SetCrashHandlerFilter@4 endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   1. _AddCrashHandlerLimitModule@4

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __stdcall AddCrashHandlerLimitModule(x)
		public _AddCrashHandlerLimitModule@4
